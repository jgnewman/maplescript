---
@private isRemoval

Determines whether a patch object created by virtual-dom indicates
a node will be removed from the dom.
---
(make (isRemoval patch)
  (all
    (= patch.patch undefined)
    (= patch.type 7)))

---
@private isAddition

Determines whether a patch object created by virtual-dom indicates
a node will be added to the dom
---
(make (isAddition patch)
  (all
    (= :vnode (m:typeof patch.patch))
    (= patch.type 6)
    (= patch.vNode null)))

---
@private collectChildHooks

Loops over an array of objects where each contains :removals and :additions.
Flattens this array into a single object with the same properties.
---
(make

  (collectChildHooks childPatches)
    (collectChildHooks childPatches { :removals [] :additions [] })

  (collectChildHooks [] accum)
    accum

  (collectChildHooks [first|rest] accum)
    (collectChildHooks rest { :removals (accum:removals.concat first:removals)
                              :additions (accum:additions.concat first:additions) }))

---
@private getChildHooks

A function for looping over child nodes and returning their hook-ready nodes.
---
(make (getChildHooks patch)
  (if

    -- When there are child patches, flatten their hooks and return them
    patch.patch?.children
      (do (make children (Array.prototype.slice.call patch.patch.children))
          (make childPatches (children.map (@ [child] (flattenHooks child))))
          (collectChildHooks childPatches))

    -- When there are no child patches, return empty lists
    :else
      { :removals [] :additions [] }))

---
@private flattenHooks

Takes an array of patch objects where each might have nested children.
Recursively iterates over this array and all existing children, and produces
a single object containing two flattened arrays. These arrays contain all of
the patches with hooks for aftermount hooks and beforeunmount hooks.
---

(make

  -- Called with just the patches, recurse with object keys and accumulators
  (flattenHooks patches)
    (flattenHooks patches (m:keys patches) [] [])

  -- Called with an empty list of object keys, return the accumulators
  (flattenHooks patches [] removals additions)
    { :removals removals :additions additions }

  -- Called with everything, recurse and accumulate
  (flattenHooks patches [first|rest] removals additions)
    (do

      -- Reference the patch in question and handle its children if they exist
      (make patch (m:get patches first))
      (make childHooks (getChildHooks patch))

      (if

        -- For removals, all children are being removed as well so we
        -- can concat child patches into the removals list
        (isRemoval patch)
          (flattenHooks patches
                        rest
                        (removals.concat childHooks:removals patch)
                        (additions.concat childHooks:additions))

        -- For additions, all children are being added as well so we
        -- can concat child patches into the additions list
        (isAddition patch)
          (flattenHooks patches
                        rest
                        (removals.concat childHooks:removals)
                        (additions.concat childHooks:additions patch))

        -- Otherwise, we're just recursing and not doing anything
        :else
          (flattenHooks patches rest removals additions))))

---
@public applyPatches

Compares two virtual trees, finds differences, and then applies those
differences to a tree of real nodes. Before applying patches, runs
any existing beforeunmount hooks. After applying patches, runs any existing
aftermount hooks.

@param {VNode}   prevTree  The virtual dom as existing prior to updating.
@param {VNode}   nextTree  The virtual dom we want to move to.
@param {Element} nodes     The actual dom nodes to be updated.
---
(make (applyPatches prevTree nextTree nodes)
  (do (make changes (m:vdom:diff prevTree nextTree))

      -- Un-nest the patches
      (make hooks (flattenHooks changes))

      -- For everything that looks like a removal, call before-unmount
      (hooks:removals.forEach
        (@ [patch]
          (if patch.vNode?:lifecycle?:before-unmount
            (patch.vNode:lifecycle:before-unmount))))

      -- Apply the changes
      (m:vdom:patchNodes nodes changes)

      -- For everything that looks like an addition, call after-mount
      (hooks:additions.forEach
        (@ [patch]
          (if patch.patch?:lifecycle?:after-mount
            (patch.patch:lifecycle:after-mount))))

      -- Return the new vdom and real nodes
      { :newdom nextTree :nodes nodes }))


---
@public runInitialHooks

When mounting the virtual dom into the real dom for the first time,
recursively iterates through the virtual dom and calls all aftermount
hooks.
---
(make (runInitialHooks vtree)
  (do

    -- recurse for children
    (if vtree.children
      (do (make children (Array.prototype.slice.call vtree.children))
          (children.forEach (@ [child] (runInitialHooks child)))))

    -- call aftermount if we have it
    (if vtree:lifecycle?:after-mount
      (vtree:lifecycle:after-mount))))


---
Export functions for running initial hooks upon render and for
applying patches to the dom after re-rendering a vnode tree.
---
(export [runInitialHooks applyPatches])
